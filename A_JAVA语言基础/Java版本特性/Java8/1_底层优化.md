#JAVA8底层优化

1. HashMap
    * JAVA8之前HashMap规则  
        初始化16长度的数组，每个元素维护一个链表，往里填值时，先通过计算hashcode值并通过计算（对15取&运算），拿到数组索引；
        该索引的值（链表）若是空，直接加入链表；
        该索引的值（链表）若有值，则依序equals比较链表中所有元素，若存在相同的，替换其value，若不存在，则新增元素作为表头。  
        
        HashMap中元素数量达到数组大小的0.75时，会进行加倍扩容，然后使用transfer()方法转移原数组中数据到扩容后的数组（transfer方法其实重新计算了全部的数据在新数组的位置）
        
    * JAVA8对HashMap的优化  
        优化为数组+链表+红黑树实现,主要的目的是提高查找效率。 
        
        改变链表添加元素位置为加到链表尾部
         
        碰撞元素个数大于8且map总容量大于64的时候，链表转成红黑树，红黑树查找、删除效率更高，但是添加效率低于链表
        
2. HashSet

3. ConcurrentHashMap  
    在java1.5后出现，替代Hashtable，同样线程安全，但是效率更高，因为默认分成16段Hashtable，分16个锁保证线程安全。
    
    * JAVA8之后，采用CAS算法，无锁添加，效率高于锁
    
4. 内存结构改变
    方法区，位于堆的永久区PremGen的一部分，存储类信息，几乎不会被垃圾回收机制回收【可能会回收，条件苛刻】
    
    JAVA8将方法区从永久区剥离，永久区不再存在，取而代之的是元空间MetaSpace，使用的是物理内存，不再需要被分配内存，理论上可用内存更大。
    当元空间过大时，垃圾回收机制开启回收【因此从JAVA8开始，由于可用内存更大，垃圾回收机制触发可能性更低】