# 反射概述



### 类加载器

程序要使用某个类时，如果类还没有被加载，系统会通过加载、连接、初始化三步来实现类的初始化。

* 加载--将class文件读入内存，将静态数据转换成方法区的运行时数据，并创建其Class对象，此过程由类加载器完成

* 连接

  * 验证--检查内部结构是否正确，是否符合JVM规范，且与其它类协调一致，无安全性问题
  * 准备--为类的静态成员分配内存，并设置默认初始化【方法区中】
  * 解析--将类的二进制数据【虚拟机常量池】中的符号引用【常量名】替换为直接引用【地址】

* 初始化--执行类构造器<clinit>方法，合并静态属性及静态代码块代码

  初始化的时机有：

  * 创建类的实例
  * 访问类的静态变量
  * 调用类的静态方法
  * 初始化该类的子类时，优先初始化该类
  * 利用反射创建类或接口的class对象
  * 直接使用java.exe运行某个类
  
  不初始化的情况：
  
  * 访问静态域，只初始化真正声明该域的类，即通过子类引用父类的静态遍历，父类初始化，子类不初始化
  * 通过数组定义类引用，不会触发类初始化
  * 引用常量不会触发类初始化

##### 类加载器的分类

* 根类加载器--`BootStrap`-负责核心类加载
* 扩展类加载器--`ExtClassLoader`-负责JAVA扩展目录中的jar包加载
* 系统类加载器--`AppClassLoader`-负责开发者自己的类及依赖jar包的加载
* 自定义加载器--通过继承`ClassLoader`实现，常用于加密编译，以防止反编译工具编译出源代码，而使用自定义加载器解密。

注：使用`System.getProperty("java.class.path")`可以获得加载路径

##### 双亲委派机制

* 定义：当某个类加载器需要加载某个`.class`文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类

* 作用：
  * 防止重复加载同一个`.class`。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。
  * 保证核心`.class`不能被篡改。通过委托方式，不会去篡改核心`.clas`，即使篡改也不会去加载，即使加载也不会是同一个`.class`对象了。不同的加载器加载同一个`.class`也不是同一个`Class`对象。这样保证了`Class`执行安全。

### 反射

运行状态中，对于任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意一个属性和方法。相当变态的功能。

##### 一、四种获取Class的方式：

	1. 对象调用`getClass`方法，该方法是Object里的native方法
 	2. `Class.forName("全类名")`，该方法是Class类提供的静态方法
 	3. `类名.class`，每个类都默认有class静态属性，直接通过类名调用，此方式最安全可靠且性能最好
 	4. 对于基本类型的包装类如Integer，有静态属性TYPE，通过`Integer.TYPE`也能拿到其Class

##### 二、哪些类型有Class对象

1. `class`：外部类，成员内部类，静态内部类，局部内部类，匿名内部类
2. `interface`：接口
3. `[]`：数组
4. `enum`：枚举
5. `annotation`：注解
6. `ptimitive type`：基本数据类型
7. `void`

* 注意：

  在反射方法时，如果方法的参数是一个数组，考虑到向下兼容问题，会按照1.4的语法对待，JVM将之拆分，拆开后参数个数就不匹配了。解决方式为防止JVM将之拆分：

  * 方式一、将数组看做为Object对象，强转；
  * 方式二、new一个Object数组，将要传入的数组作为新数组的唯一元素。

* 反射示例：
  * 演示了获取`Class`、构造方法`Constructor`、成员变量`Field`、成员方法`Method`：`top.trial.reflect.ReflectDemo`
  
  * 演示了获取泛型和注解信息：
  
    `top.trial.reflect.ReflectDemo2`

