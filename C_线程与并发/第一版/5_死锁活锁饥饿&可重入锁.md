#死锁活锁饥饿与可重入锁
1. 活跃性-死锁：两个或两个以上线程在执行过程中，因争夺资源产生的一种互相等待的现象。【两个线程互相持有对方想要的锁，因而造成互相等待而无法继续向下运行的现象】
    top.trial.thread.basethread.BaseThreadTestDemo有对死锁问题的举例
    解决：
        * 采用顺序加锁的方式可以解决，但是容易产生后面的饥饿问题。
        * 采用可中断的锁，超时进行打断
        * 采用可超时锁，超时主动不再尝试获取锁
2. 活跃性-活锁：两个或两个以上线程在执行过程中，因互相改变对方的结束条件而一直运行而无法结束的现象。  
    【如初始count为10，t1线程count++直到count>20退出，t2线程count--直到count<0退出，最后两个线程启动后都达不到退出条件】
3. 活跃性-饥饿：线程由于优先级太低，始终得不到CPU时间片使用权而无法结束。
4. ReentrantLock可重入锁
    相对于synchronised，有如下特点：可中断、可设置超时时间、可设置为公平锁、支持多个条件变量
    使用方式：
        普通使用：创建ReentrantLock对象，调用lock方法加锁，调用unlock方法解锁。
            需保证加锁解锁成对出现。为保证锁能释放，一般unlock放在finally块中。
        可中断：创建ReentrantLock对象，调用lockInterruptibly方法加锁，调用unlock方法解锁。
            可被interrupt方法打断，打断后应在catch块中return。【获得锁的过程可被打断，打断后是没有获得锁，后面代码不应执行】
        可设置超时时间：创建ReentrantLock对象，调用tryLock方法加锁，参数为尝试等待时间，若无参，则不等待。
            方法返回是否获得到了锁的boolean值，一般返回false后应return，不再继续向下执行后面的代码。
            另外，带参数的tryLock可被打断。
        可设置为公平锁：ReentrantLock默认是不公平锁，通过构造方法可设置是否是公平锁。公平锁会降低并发度，其实是等待队列按顺序抢，而不是一拥而上。
        条件变量：相当于对monitor的waitSet进行了细分，减少虚假唤醒。
            调用newCondition方法获得一个条件变量，在lock方法获得锁后，可以使用condition对象的await方法进行在该condition上的等待；
            然后如果要唤醒，可以使用condition对象的signal或signalAll方法唤醒。
            注意：使用await方法需要在获得锁之后，执行await方法后会释放锁，await方法被打断或唤醒或超时后重新竞争lock锁，竞争成功后从await方法后开始执行。
    实现原理：
        建议充分了解了【A_并发工具之JUC】中关于AQS的部分之后，再研究此部分的原理
        ReentrantLock内部定义了自定义抽象类Sync继承AQS，同时自定义了NonfairSync非公平锁和FairSync公平锁两个类继承Sync
        建议充分读取lock方法的源码
        建议比较公平锁与非公平锁的源码
        需要关注以下几点：
            加锁成功流程处理
            加锁失败流程处理
            解锁后流程处理【唤醒与锁竞争机制】
            非公平锁竞争机制
            公平锁竞争机制
            锁重入原理
            锁打断原理
            条件变量【等待与唤醒】