#JMM

###原子性
保证指令不受线程上下文切换的影响

###可见性
保证指令不受CPU缓存的影响

JIT的优化：当某线程多次从主内存中加载某个变量值，则会将该变量值放到高速缓存中，当另一个线程对主内存中该变量的值修改之后，不能实时反映到缓存中。
解决方式：在共享变量上增加修饰符volatile【易变】，被该修饰符修饰的变量不被缓存，每次从主内存中读取。
        【比较适用于一个写线程，多个读线程的情况】
        【可保证可见性，但保证不了原子性】  
        其实，加上synchronized锁也可以解决，不过过于重量级，不推荐
        【synchronized既可保证原子性，也可保证可见性】

###有序性
保证指令不受CPU指令并行优化的影响
指令重排：JVM在不影响正确性的前提下，可能调整语句执行顺序，但是在多线程情况下，这就会影响程序的正确性。
如何禁用：JVM会禁用方法中volatile修饰的变量前面的语句的指令重排【仅保证本线程内相关代码不被重排。解决不了指令交错问题】
注意：如果可能被重排序代码涉及到的变量的使用语句全都包在synchronized中，就算出现重排序，也不会出现有序性问题。

###volatile原理【1.5版本后生效】
底层实现原理是内存屏障：
    对volatile变量的写指令后会加入写屏障，写屏障保证在该屏障之前的对共享变量的变动都同步到主存中。
    对volatile变量的读指令前会加入读屏障，读屏障保证在该屏障之后的对共享变量的读取都加载主存中最新数据。
    此项保证了可见性和有序性【仅保证本线程内相关代码不被重排】，保证不了原子性
    案例分析：double-checked locking问题以及解决---示例【top.trial.concurrent.designPattern.DoubleCheckedLocking】
    
###happens-before规则
happens-before规则保证对共享变量的写操作对其他线程的读操作可见，是可见性和有序性的一套规则的总结。若不满足规则，JVM无法保证一个写操作对其他线程的读操作可见。
1. 写线程与读线程使用synchronized包围共享变量，且使用同一把锁。
2. 使用volatile修饰共享变量，写线程在写指令后加入写屏障，同步到了主存中，读线程在读指令前加入读屏障，读加载主存中最新数据，因此保证可见。
3. 读线程启动前共享变量的写入，读线程开始后对该共享变量可见。
4. 写线程关闭后，读线程对该共享变量可见。
5. 写线程打断某个读线程前的共享变量的写入，其它读线程得知该读线程被打断后对该共享变量可见。
6. 对变量默认值的写，读线程对该共享变量可见。
7. 传递性，由于写屏障，对于volatile修饰的共享变量，在其写语句之前的其它共享变量的写，读线程对这些共享变量都可见。