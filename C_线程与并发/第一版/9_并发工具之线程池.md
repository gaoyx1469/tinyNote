#并发工具之线程池
高并发情况下，并不是线程越多越好，因为过多线程会导致频繁的上下文切换从而影响效率，
甚至过多的创建线程有可能导致内存溢出，
因此合理利用已有线程而不是每次创建新线程，是更加合理的并发编程方式。

#ThreadPoolExecutor
使用一个int【AtomicInteger ctl】表示线程池状态和池内线程数量，前3位是池状态，后29位是池数量，目的是两者能使用一个CAS操作就同时更新，保证原子性。
    池状态：
        -1【111】RUNNING      可接收新任务，可处理阻塞队列任务
        0【000】 SHUTDOWN     不可接收新任务，可处理阻塞队列任务【执行完阻塞队列剩余任务】
        1【001】 STOP         不可接收新任务，不可处理阻塞队列任务【中断正执行的任务，抛弃阻塞队列中任务】
        2【010】 TIDYING      【任务全部执行完毕，活动线程变为0时，为此状态，下一步将进入终结状态】
        3【011】 TERMINATED   【终结状态】
核心线程--需要时创建，不用时放回线程池
救急线程--需要时创建，不用时达到生存时间会销毁，最多创建（最大线程数-核心线程数）
拒绝策略--
    JDK提供了：AbortPolicy抛异常【默认】、CallRunsPolicy让调用者线程执行该任务、DiscardPolicy抛弃该任务、DiscardOldestPolicy抛弃队列最早任务
    三方框架提供了：抛异常加日志记录并dump线程栈信息【Dubbo】、再创建新线程执行此任务【Netty】、等待超时60s方式【ActiveMQ】、逐一尝试策略链中的拒绝策略【PinPoint】
    
Executors类是线程池工具类，提供了多种创建线程池的方法
SynchronousQueue同步队列类，没有容量，只有当一个线程来取时，put才能成功，其只作为临时中介的作用。

Timer简单定时调度，所有任务由同一线程调度，因此所有任务都是串行的，前面的任务执行超时或出现异常都会影响后面任务的按时执行
ScheduledExecutorService任务调度线程池，取代Timer，
    延时调度
    延时循环调度
    延时循环延迟调度

创建多大的线程池合适：
    CPU密集型，建议核心数+1
    I/O密集型，建议核心数/利用率

#Fork/Join模式
采用分治思想，将大任务拆分成算法上相同的小任务。
该线程池默认创建CPU核心数大小的线程
实际使用见Java8中【5_Fork&Join】