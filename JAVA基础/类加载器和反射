类加载器
	程序要使用某各类时，如果类还没有被加载，系统会通过加载、连接、初始化三步来实现类的初始化。
	加载（由类加载器实现）：
		将class文件读入内存，并为之创建一个Class对象。
	连接：
		验证--是否内部结构正确，与其它类协调一致
		准备--为类的静态成员分配内存，并设置默认初始化
		解析--将类的二进制数据中的符号引用替换为直接引用
	初始化：
	
	
	初始化时机：
		创建类的实例
		访问类的静态变量
		调用类的静态方法
		利用反射创建某各类或接口对应测class对象
		初始化某各类的子类
		利用java.exe直接运行某各类
		
	类加载器
		根类加载器【BootStrap】：负责Java核心类（rt.jar）的加载
		扩展类加载器【ExtClassLoader】：负责Java扩展目录（ext目录）中jar包的加载
		系统类加载器【AppClassLoader】：开发者自己写的类（即类路径下的类）的加载
		
	自定义类加载器
		继承Classloader
		常见使用：加密【加密编译，使反编译工具无法反编译出源代码，而使用自定义的类加载器，实现解密】
		
反射：
	运行状态中，对于任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意一个属性和方法。
	
	注意：
		在反射方法时，如果方法的参数是一个数组，考虑到向下兼容问题，会按照1.4的语法对待，JVM将之拆分，拆开后参数个数就不匹配了；
		解决方式为防止JVM将之拆分，解决方式：
			方式一、将数组看做为Object对象，强转；
			方式二、new一个Object数组，将要传入的数组作为新数组的唯一元素。
	
	示例：
	/SimpleGOD/src/top/tiral/reflect/ReflectDemo.java
	
动态代理：
	基于接口的动态代理：
		程序运行中产生对象，即通过反射生成的一个代理
		多使用匿名内部类
	基于子类的动态代理：
		多使用匿名内部类
	
	示例：
		基于接口的动态代理：
			/SimpleGOD/src/top/tiral/reflect/ProxyDemo.java
		基于子类的动态代理：
			/SimpleGOD/src/top/trial/reflect/ProxyDemo2.java
	