排序
	初级排序算法：冒泡排序、选择排序、插入排序
		冒泡排序：
			算法描述：指的是最基本的交换排序，相邻元素两两比较，根据大小交换位置。
			排序性能：稳定排序，时间复杂度O(N^2)，空间复杂度O(1)
			优化点：增加是否已经有序的判断，减少循环次数；增加有序边界判断，减少循环次数。
			变种：鸡尾酒排序--改变单向冒泡的方式，变成双向来回冒泡。
			适合场景：
				1/	元素交换次数依赖于原始数组的有序程度，原始数组大部分有序时适用
			代码实现：/SimpleGOD/src/top/trial/sort/BubbleSort.java

		选择排序：
			算法描述：挑选最小元素，与未排序序列第一个元素交换位置。
			排序性能：不稳定排序，时间复杂度O(N^2)，空间复杂度O(1)
			优化点：
			适合场景：
				1/	元素交换次数固定，原始数组大部分无序时适用
			代码实现：/SimpleGOD/src/top/trial/sort/SelectionSort.java

		插入排序：
			算法描述：维护一个有序区，将元素一个一个插入到有序区适当的位置，直到所有元素有序
			排序性能：稳定排序，时间复杂度O(N^2)，空间复杂度O(1)
			优化点：将要插入的元素缓存，减少交换次数
			适合场景：
				1/	元素交换次数依赖于原始数组的有序程度，交换性能优于冒泡排序，原始数组大部分有序时适用
			代码实现：/SimpleGOD/src/top/trial/sort/InsertionSort.java

		初级排序算法比较：
			冒泡排序稳定，但是交换次数多；选择排序不稳定，但是交换次数少；插入排序稳定，交换次数中等。
			算法选择：
				看原始数组有序程度，基本有序选冒泡或插入【插入略优于冒泡】，基本无序用选择排序
				看是否需要稳定，需要则用冒泡或插入【插入略优于冒泡】

	中级排序算法：希尔排序，快速排序，归并排序，堆排序
		希尔排序：
			算法描述：【高级优化版插入排序】，将元素隔段分组，再进行直接插入排序。思想：元素数量较少时，插入排序工作量较小【隔段分若干组进行插入排序】、大部分元素已经有序的情况下，插入排序工作量较小【分组排序后大部分已有序】
			排序性能：不稳定排序，时间复杂度不定，看增量的设计方式。Hibbard增量最坏时间复杂度为O(n^(3/2))，Sedgewick增量最坏时间复杂度为O(n(4/3))
			优化点：选择合适的增量
				希尔增量：2^(k-1)	序列为1,2,4,8
				Hibbard增量：2^k-1	序列为1,3,7,15
				Sedgewick增量：9*4^k-9*2^k+1 或 4^k-3*2^k+1	序列为1,5,19,41,109
			适合场景：
			代码实现：/SimpleGOD/src/top/trial/sort/ShellSort.java

		快速排序：
			算法描述：【高级优化版冒泡排序】，使用分治法，每一轮挑选一个基准元素，并让其余比它大的元素移动到数列一边，比它小的元素移动到数列另一边
			排序性能：不稳定排序，平均时间复杂度O(nlogn)，最坏时间复杂度O(n^2)
			优化点：
				基准元素pivot的选择--随机选择
				元素移动方式的选择--挖坑法和指针交换法
			适合场景：
			代码实现：/SimpleGOD/src/top/trial/sort/QuickSort.java

		归并排序：
			算法描述：将数据分组，小组内排序后进行小组间比较排序，形成大组，最终完成全部排序
			排序性能：稳定排序，平均时间复杂度O(nlogn)，空间复杂度O(n)
			优化点：
			适合场景：
			代码实现：/SimpleGOD/src/top/trial/sort/MergeSort.java

		堆排序：
			算法描述：构建二叉堆，依次删除堆顶元素，移到集合尾部，调节堆产生新的堆顶。
			排序性能：不稳定排序。时间复杂度O(nlogn)，空间复杂度O(1)
			优化点：
			适合场景：
			代码实现：/SimpleGOD/src/top/trial/sort/HeapSort.java

		中级排序算法比较：
			堆排序由于二叉堆父子节点不连续，因此性能稍低
			快速排序和堆排序是原地排序，不稳定；归并排序是非原地排序，稳定。

	高级排序算法：计数排序，桶排序，基数排序
		计数排序：
			算法描述：根据待排序数组的取值范围构建新数组，遍历待排序数组，给新数组下标等于遍历值的数加1，然后遍历新数组即可
			排序性能：时间复杂度O(n+m)，空间复杂度O(n)，原始版为不稳定排序，优化版为稳定排序
			优化点：新数组构建长度选择；稳定性实现
			适合场景：适用于一定范围内的整数排序
			代码实现：/SimpleGOD/src/top/trial/sort/CountSort.java

		桶排序：
			算法描述：类比计数排序，桶排序构建与原始数组长度一样数量的桶，除最后一个桶只包含数列最大值，前面各桶按比例确定区间。遍历原始数组放到桶中，桶内元素分别排序，遍历桶即可
			排序性能：时间复杂度O(n+m+n(logn-logm))，空间复杂度O(m+n)，当m与n相同，最佳时间复杂度和空间复杂度都是O(n)，最差时间复杂度O(nlogn)
			优化点：
			适合场景：
			代码实现：/SimpleGOD/src/top/trial/sort/BucketSort.java

		基数排序：
			算法描述：把字符串或数字按位拆分，每一位进行一次计数排序，即为基数排序。
			排序性能：
			优化点：
			适合场景：适用于电话号码后和单词排序等
			代码实现：/SimpleGOD/src/top/trial/sort/RadixSort.java

		高级排序算法比较：



    总结：
        方法名		|	平均情况			|	最好情况		|	最坏情况		|	空间复杂度	|	稳定性	|	原理及优势

        直接插入排序	|	O(n^2)			|	O(n)		|	O(n^2)		|	O(1)		|	稳定		|	将记录插入有序表，对小数据量的排序有优势，占用空间小
        冒泡排序		|	O(n^2)			|	O(n)		|	O(n^2)		|	O(1)		|	稳定		|	相邻记录两两比较交换，类似直接插入排序，适合小数据量且近似有序的数据
        简单选择排序	|	O(n^2)			|	O(n^2)		|	O(n^2)		|	O(1)		|	稳定		|	选出最小关键字记录放到合适位置，适合单条记录比较庞大不适合移动的情况

        希尔排序		|	O(n^2)~O(nlogn)	|	O(n^1.3)	|	O(n^2)		|	O(1)		|	不稳定	|	间隔比较

        快速排序		|	O(nlogn)		|	O(nlogn)	|	O(n^2)		|	O(logn)~O(n)|	不稳定	|	选枢轴将元素分成两部分，递归调用，适合大数据量的情况
        堆排序		|	O(nlogn)		|	O(nlogn)	|	O(nlogn)	|	O(1)		|	不稳定	|	构造大顶堆/小顶堆，选出根元素，不递归，空间占用少，适合内存小的情况
        归并排序		|	O(nlogn)		|	O(nlogn)	|	O(nlogn)	|	O(n)		|	稳定		|	采用非递归方式，两两比较排序合并，适合大数据量且稳定性有要求的情况