查找
	静态查找：仅查找【适合使用线性存储结构，顺序查找或排序后二分查找】
	动态查找：查找，并插入或删除【适合二叉排序树查找】
	
	一、顺序查找：线性查找，从表中第一个记录开始一个一个对比关键字。时间复杂度O(n)。
		可以设置哨兵以替代越界判断
	二、有序表查找-折半查找：二分查找【需要有序且线性表是顺序存储结构，由于维护有序所需工作量大，因此不适应于动态查找】。时间复杂度O(logn)，涉及加法和除法。
	三、有序表查找-插值查找：在二分查找的基础上，依据要查找的值，不从中间二分，而是low+((key-a[low])/(a[high]-a[low]))*(high-low)作为新的二分点，涉及复杂四则运算。
	四、有序表查找-斐波那契查找：在二分法查找的基础上，不从中间二分，而是依据斐波那契数列属性，将其分为F(k-1)和F(k-2)两部分。
	五、无序表查找-线性索引查找：
		索引是把一个关键字与它对应的记录相关联的过程。
		线性索引就是将索引项集合组织为线性结构-索引表【索引表有序】。
			稠密索引：线性索引中将数据集中每个记录对应一个索引项，索引项按照关键字有序排列。数据量巨大时性能大大下降。索引项包括关键字和对应数据的指针。
			分块索引：把数据集的记录分成若干块，并且这些块内无序、块间有序。每一块对应一个索引项以减少索引数量。索引项包括最大关键字，记录个数及块首数据指针。
			倒排索引：使用记录号表存储具有相同次关键字的所有记录的记录号【指针或关键字】
	六、二叉排序树：二叉查找树【既有有序表查找的速度优势，又有无序表增加的速度优势】
		构建二叉树，中序遍历可得到有序序列
		查找时通过递归一层一层查找
		增加时同样一层一层比较，插入合适位置
		删除时，删除叶子结点容易；删除的结点只有左子树或只有右子树，则将子树接到双亲结点即可；删除的结点既有左子树又有右子树，取要删除的结点的前驱或后继来替代要删除的结点，而这个前驱或后继肯定是叶子结点或只有一个子树的结点。
		
	七、平衡二叉树【AVL树】：克服二叉排序树不平衡，使每一个结点的左子树和右子树高度相差不超过1。查找和增删的时间复杂度都是O(logn)
		平衡因子BF：左子树深度-右子树深度。平衡二叉树的任一结点的BF只能是-1、0、1。
		最小不平衡子树：平衡因子绝对值大于1的离插入结点最近的结点为根的子树。
		构造平衡二叉树就是构造二叉排序树时，调整最小不平衡子树的过程。具体操作：
			根结点与其子结点的BF同时为正或负：
				BF为正，整棵树直接右旋；BF为负，整棵树直接左旋。
				旋转后第三叉的处理-->作为原根节点的另一叉
			根结点与其子结点的BF符号不一致：
				先将符号不一致的子树旋转，使符号一致。
				子结点BF为正，右旋；子结点BF为负，左旋。
	
	八、多路查找树：每一个结点的孩子可以有多个，每一个结点处可以储存多个元素。其有多种形式：
		2-3树：每一个结点都有两个或三个子结点。叶结点补齐和空位补满？
		2-3-4树：每一个结点都有两个或三个或四个子结点。
		B树：平衡的多路查找树，2-3树和2-3-4树都是其特例，分别是3阶B树和4阶B树。
			若根结点不是叶结点，则至少有两棵子树
			每一个非根分支结点都有k-1个元素和k个孩子
			所有叶子结点位于同一层次
			应用：当数据量很大的时候，每一次读取一个结点【M个元素】到内存中。读其子结点或双亲结点，需要再次从磁盘读取
		B+树：分支结点中的元素会被当作它们在该分支结点位置的中序后继者再次列出，且所有叶子结点都链接在一起
			
	九、散列表查找：哈希表查找
		直接通过关键字得到要查找的记录的位置，而不用比较。散列技术：在记录的存储位置和它的关键字之间简历一种确定的对应关系f(n)，使得每个记录的关键字可以对应一个存储位置
		散列技术既是存储技术，也是查找方法。最适合求解查找与给定值相等的记录，不适合范围查找以及排序、求取最大最小值等。
		设计一个对应关系使散列函数简单、均匀、存储利用率高使核心点，处理冲突【不同关键字，散列函数结果一致】是难点。
		常用散列函数设计：【注意点：计算时间、关键字长度、关键字分布、散列表长度、查找频率等】
			直接地址法：去关键字的线性函数值。f(key)=a*key+b。适合查找表小且连续的情况，不常用。
			数字分析法：使用关键字的一部分计算散列存储位置的方法。适合知道关键字分布且关键字某一部分分布均匀的情况。如手机号后四位。
			平方取中法：关键字乘方后取中间几位。适合不知道关键字分布且关键字位数不是很大时。
			折叠法：关键字均匀分成几部分后相加并取后几位。适合不知道关键字分布且关键字位数较大时。
			除留余数法：最常用。对关键字直接取模或者对关键字的折叠或平方后取模。f(key)=key MOD p。p要选好，通常取小于散列表长度的质数。
			随机数法：选择一个随机数，取关键字的随机函数值。f(key)=random(key)。
		散列函数冲突处理：
			开放定址法：f1(key) = (f(key) + d) MOD m。
				【线性探测法】：d的取值为从1到m-1依次实验，有空位就存入。
				【二次探测法】：d的取值为从1 、 -1、4、-4、9、-9....依次实验，有空位就存入。
				【随机探测法】：d的取值是一个随机数列
			再散列函数法：准备多个不同f(key)，一个不行换另一个。计算时间会增加
			链地址法：冲突不用处理，直接接在链表后。查找需要遍历单链表，增加时间复杂度。
			公共溢出区法：给出一个溢出表，基本表没数据则没有，有相等数据则返回，有不等数据则去溢出表顺序查找。适合冲突少的数据。
		散列表性能分析：
			无冲突的散列表，时间复杂度O(1)。
