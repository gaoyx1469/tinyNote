排序
	排序问题中，数据元素称为记录，输入一个记录集合，返回一个有序记录集合。
	排序依据是关键字，对不同关键字排序有不同。多关键字排序最终可以转化为单关键字排序。
	
	排序稳定性：关键字相等的元素，排序前后顺序不变称为稳定，排序前后顺序颠倒称为不稳定。
	内排序：待排序记录全部在内存中。
	外排序：待排序记录太多，部分在内存中，排序过程涉及内外存数据交换。
	
	内排序性能分析：
		时间性能：尽可能少的比较和移动，其中移动可以通过合适的存储结构来避免。
		辅助空间：执行算法的其它存储空间
		算法复杂度：算法本身的复杂度
		
	总结：
		方法名		|	平均情况			|	最好情况		|	最坏情况		|	空间复杂度	|	稳定性	|	原理及优势
		
		直接插入排序	|	O(n^2)			|	O(n)		|	O(n^2)		|	O(1)		|	稳定		|	将记录插入有序表，对小数据量的排序有优势，占用空间小
		冒泡排序		|	O(n^2)			|	O(n)		|	O(n^2)		|	O(1)		|	稳定		|	相邻记录两两比较交换，类似直接插入排序，适合小数据量且近似有序的数据
		简单选择排序	|	O(n^2)			|	O(n^2)		|	O(n^2)		|	O(1)		|	稳定		|	选出最小关键字记录放到合适位置，适合单条记录比较庞大不适合移动的情况
		
		希尔排序		|	O(n^2)~O(nlogn)	|	O(n^1.3)	|	O(n^2)		|	O(1)		|	不稳定	|	间隔比较
			
		快速排序		|	O(nlogn)		|	O(nlogn)	|	O(n^2)		|	O(logn)~O(n)|	不稳定	|	选枢轴将元素分成两部分，递归调用，适合大数据量的情况
		堆排序		|	O(nlogn)		|	O(nlogn)	|	O(nlogn)	|	O(1)		|	不稳定	|	构造大顶堆/小顶堆，选出根元素，不递归，空间占用少，适合内存小的情况
		归并排序		|	O(nlogn)		|	O(nlogn)	|	O(nlogn)	|	O(n)		|	稳定		|	采用非递归方式，两两比较排序合并，适合大数据量且稳定性有要求的情况
				
	
	内排序-插入排序：
		直接插入排序：时间复杂度O(n^2)，比冒泡和简单选择排序稍好一些
			将记录插入到已排序的有序表里，从而得到记录数加1的有序表
		希尔排序
			时间复杂度O(n^(3/2))
			下标隔3个两两比较，排序；然后下标隔两个两两比较，再排序；然后下标相邻两个两两排序，得到最终结果。
	内排序-交换排序：
		简单交换排序：时间复杂度O(n^2)
			从头开始比较元素与其后面元素的大小，反序则交换，最终将最小的关键字元素移到最前。【将最小元素筛选到最前】
			缺点：效率低下，当前筛选的过程，对其余元素排序没有帮助
		冒泡排序：时间复杂度O(n^2)
			两两比较相邻记录的关键字，反序则交换。【将最大元素筛选到最后】
			比起简单交换排序，对其余元素也有梳理作用
		优化版冒泡排序：	时间复杂度O(n^2)
			继续优化-->增加一个布尔类型标识，当后面已经已经没有交换的时，结束循环。
		快速排序：
			通过一次排序将待排序记录分割成独立的两部分，其中一部分关键字均比另一部分关键字小，之后对两部分继续进行排序即可。
			同样需要 递归思想
			重点是：拿到一个枢轴，将其放到正确位置上，使得前面的数据均小于它，后面的数据均大于它，并返回它的下标。
				算法就是将选取的枢轴不断交换，将小于它的放到前面，大于它的放到后面。
			时间复杂度O(nlogn) 空间复杂度O(logn) 不稳定排序
		优化版快排：
			三数取中法，取左、右、中三个数里的中位数作为枢轴，避免枢轴取得太小或太大
			九数取中法，三个三数取中后再三数取中
			使用替换取代交换
			当待排序数据元素较少时，使用直接插入排序更合适
	内排序-选择排序：
		简单选择排序：
			时间复杂度O(n^2)，性能略优于交换排序，毕竟移动少了。
			从头开始比较元素与后面元素的大小，筛选出最小的一个，与头上的元素交换。
		堆排序：
			堆：堆是满足下列条件的完全二叉树：每个结点大于【大顶堆】或小于【小顶堆】其子结点。
			将待排序数组构造成大顶堆/小顶堆，则跟结点就是最大或最小值，移走后继续重新构造其它元素成新的顶堆。
			问题：
				如何构造初始大顶堆
				移走根结点后，如何重排大顶堆
			时间复杂度O(nlogn)
	内排序-归并排序
		二路归并排序：n条记录两两归并排序，然后再两两归并排序...
			一：采用递归思想，关键点在于合并算法上-->其实就是双指针法，每次合并都初始化一个要合并大小的数组
				时间复杂度O(nlogn) 空间复杂度O(n+logn)	占用内存但效率高且稳定
			二：不采用递归思想，关键点同样在合并算法上-->同样采用双指针法，初始化一个全长度的数组，每次合并都是两个数组之间倒腾
				时间复杂度O(nlogn) 空间复杂度O(n)
