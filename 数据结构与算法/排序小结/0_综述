排序
	初级排序算法：冒泡排序、选择排序、插入排序
		冒泡排序：
			算法描述：指的是最基本的交换排序，相邻元素两两比较，根据大小交换位置。
			排序性能：稳定排序，时间复杂度O(N^2)，空间复杂度O(1)
			优化点：增加是否已经有序的判断，减少循环次数；增加有序边界判断，减少循环次数。
			变种：鸡尾酒排序--改变单向冒泡的方式，变成双向来回冒泡。
			适合场景：
				1/	元素交换次数依赖于原始数组的有序程度，原始数组大部分有序时适用
			代码实现：/SimpleGOD/src/top/trial/sort/BubbleSort.java
			
		选择排序：
			算法描述：挑选最小元素，与未排序序列第一个元素交换位置。
			排序性能：不稳定排序，时间复杂度O(N^2)，空间复杂度O(1)
			优化点：
			适合场景：
				1/	元素交换次数固定，原始数组大部分无序时适用
			代码实现：/SimpleGOD/src/top/trial/sort/SelectionSort.java
			
		插入排序：
			算法描述：维护一个有序区，将元素一个一个插入到有序区适当的位置，直到所有元素有序
			排序性能：稳定排序，时间复杂度O(N^2)，空间复杂度O(1)
			优化点：将要插入的元素缓存，减少交换次数
			适合场景：
				1/	元素交换次数依赖于原始数组的有序程度，交换性能优于冒泡排序，原始数组大部分有序时适用
			代码实现：/SimpleGOD/src/top/trial/sort/InsertionSort.java
		
		初级排序算法比较：
			冒泡排序稳定，但是交换次数多；选择排序不稳定，但是交换次数少；插入排序稳定，交换次数中等。
			算法选择：
				看原始数组有序程度，基本有序选冒泡或插入【插入略优于冒泡】，基本无序用选择排序
				看是否需要稳定，需要则用冒泡或插入【插入略优于冒泡】
				
	中级排序算法：希尔排序，快速排序，归并排序，堆排序
		希尔排序：
			算法描述：【高级优化版插入排序】，将元素隔段分组，再进行直接插入排序。思想：元素数量较少时，插入排序工作量较小【隔段分若干组进行插入排序】、大部分元素已经有序的情况下，插入排序工作量较小【分组排序后大部分已有序】
			排序性能：不稳定排序，时间复杂度不定，看增量的设计方式。Hibbard增量最坏时间复杂度为O(n^(3/2))，Sedgewick增量最坏时间复杂度为O(n(4/3))
			优化点：选择合适的增量
				希尔增量：2^(k-1)	序列为1,2,4,8
				Hibbard增量：2^k-1	序列为1,3,7,15
				Sedgewick增量：9*4^k-9*2^k+1 或 4^k-3*2^k+1	序列为1,5,19,41,109
			适合场景：
			代码实现：/SimpleGOD/src/top/trial/sort/ShellSort.java
			
		快速排序：
			算法描述：【高级优化版冒泡排序】，使用分治法，每一轮挑选一个基准元素，并让其余比它大的元素移动到数列一边，比它小的元素移动到数列另一边
			排序性能：不稳定排序，平均时间复杂度O(nlogn)，最坏时间复杂度O(n^2)
			优化点：
				基准元素pivot的选择--随机选择
				元素移动方式的选择--挖坑法和指针交换法
			适合场景：
			代码实现：/SimpleGOD/src/top/trial/sort/QuickSort.java
			
		归并排序：
			算法描述：将数据分组，小组内排序后进行小组间比较排序，形成大组，最终完成全部排序
			排序性能：稳定排序，平均时间复杂度O(nlogn)，空间复杂度O(n)
			优化点：
			适合场景：
			代码实现：/SimpleGOD/src/top/trial/sort/MergeSort.java
			
		堆排序：
			算法描述：构建二叉堆，依次删除堆顶元素，移到集合尾部，调节堆产生新的堆顶。
			排序性能：不稳定排序。时间复杂度O(nlogn)，空间复杂度O(1)
			优化点：
			适合场景：
			代码实现：/SimpleGOD/src/top/trial/sort/HeapSort.java
			
		中级排序算法比较：
			堆排序由于二叉堆父子节点不连续，因此性能稍低
			快速排序和堆排序是原地排序，不稳定；归并排序是非原地排序，稳定。
		
	高级排序算法：计数排序，桶排序，基数排序
		计数排序：
			算法描述：根据待排序数组的取值范围构建新数组，遍历待排序数组，给新数组下标等于遍历值的数加1，然后遍历新数组即可
			排序性能：时间复杂度O(n+m)，空间复杂度O(n)，原始版为不稳定排序，优化版为稳定排序
			优化点：新数组构建长度选择；稳定性实现
			适合场景：适用于一定范围内的整数排序
			代码实现：/SimpleGOD/src/top/trial/sort/CountSort.java
			
		桶排序：
			算法描述：类比计数排序，桶排序构建与原始数组长度一样数量的桶，除最后一个桶只包含数列最大值，前面各桶按比例确定区间。遍历原始数组放到桶中，桶内元素分别排序，遍历桶即可
			排序性能：时间复杂度O(n+m+n(logn-logm))，空间复杂度O(m+n)，当m与n相同，最佳时间复杂度和空间复杂度都是O(n)，最差时间复杂度O(nlogn)
			优化点：
			适合场景：
			代码实现：/SimpleGOD/src/top/trial/sort/BucketSort.java
			
		基数排序：
			算法描述：把字符串或数字按位拆分，每一位进行一次计数排序，即为基数排序。
			排序性能：
			优化点：
			适合场景：适用于电话号码后和单词排序等
			代码实现：/SimpleGOD/src/top/trial/sort/RadixSort.java
			
		高级排序算法比较：