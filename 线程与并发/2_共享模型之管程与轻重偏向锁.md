#共享模型

1. 临界区：一段代码块存在对共享资源的多线程读写
2. 竞态条件：多个线程在临界区执行导致结果无法预测
3. synchronized对象锁  
	采用互斥的方式，让同一时间最多一个线程持有对象锁，上下文切换不释放锁，这样拥有锁的线程可以安全运行临界区代码。  
	synchronized内的代码执行完，会唤醒被锁挡住的其它blocked状态的线程。  
	使用synchronized保证了临界区代码的原子性。
4. 不可变类如String是线程安全的
5. 线程安全的类如Vector的方法可看成原子的，但是多个方法的组合操作就不是原子性的了，需要谨慎判断是否有线程安全问题
6. 对象头的概念：【32位虚拟机下：】普通对象8字节，数组对象12字节，其中，Mark Word 4个字节，Klass Word存字节码地址 4个字节，数组长度 4个字节  
7. Mark Word结构
8. Monitor管程/监视器（锁）：每个对象可以关联一个Monitor对象【操作系统的对象】。
    使用synchronized给对象加上重量级锁，对象头的Mark Word就设置成指向Monitor对象的指针，当某个线程走到这段代码，Monitor对象的Owner属性将关联当前访问线程；
    当第二个线程走到这里，第一个线程没有执行完，则Monitor对象的EntryList属性（阻塞队列）将加入第二个线程，第二个线程变为BLOCKED阻塞状态；
    当第一个线程执行完，Monitor对象的Owner属性置为空，唤醒Monitor对象的EntryList属性中的线程，竞争一番后，新的Owner出现，其余继续阻塞。
9. JAVA6优化了synchronized加锁方式，新增了轻量级锁和偏向锁
    轻量级锁：多线程访问时间是错开的，可以使用轻量级锁进行优化，对使用者透明，依然使用synchronized加锁，当轻量级锁发现了访问时间冲突，锁膨胀
        使用分析-加锁：若锁对象是未加锁状态，Mark Word最后为01，此时将Mark Word与线程的锁记录栈新生成一个锁记录的锁地址+00相交换，锁记录栈记录了锁对象的Mark Word，锁对象记录了锁地址；
            若有其它线程遇到synchronized同一锁对象，看到状态为00，即知道遇到轻量级锁，进入锁膨胀过程；
            若是当前线程执行了synchronized锁重入，看到状态为00，且判断到锁对象现在的Mark Word中的锁地址正好是当前线程，即知道轻量级锁重入，新生成的锁记录不再与Mark Word进行交换，而是将锁地址位置置空。【保留该锁记录可用于重入计数】
        使用分析-解锁：若退出synchronized代码块，且锁记录栈顶的锁记录地址栏是null，表示有锁重入，删掉栈顶锁记录即可；
            若锁记录栈顶的所记录地址栏是锁对象的Mark Word，则将之恢复给锁对象，若能恢复成功，则解锁成功，若恢复失败，表示轻量级锁进行了锁膨胀，继续执行重量级锁解锁流程
    锁膨胀：轻量级锁加锁后，其它线程访问，发现Mark Word最后为00，则为锁对象申请Monitor，让锁对象的Mark Word指向重量级锁地址，Monitor的Owner指向锁对象原Mark Word指向的线程，而自身则进入EntryList阻塞
    自旋优化：重量级锁竞争时，线程1持有锁，若线程2进行到同步代码块，则线程2先自旋重试几次，看线程1有没有释放锁，失败了再阻塞，成功了就可以直接持有锁。
        【优化原因是阻塞涉及上下文切换等复杂操作，耗费资源和时间。】
        【JAVA6后自旋是自适应的，若刚自旋成功过，则认为自旋成功率高，自旋尝试次数会多几次，反之，减少自旋次数甚至不自旋】
    偏向锁：对轻量级锁的锁重入进行了优化，Mark Word中biased_lock为1，即该对象开启了偏向锁。
        偏向锁有延迟特性，程序运行几秒钟后产生的对象才是开启偏向锁的对象，可以调整VM参数使偏向锁启动延时为0
        只有第一次加锁时，将线程ID记入到Mark Word中【64位系统将记在前54位中】，解锁后，Mark Word中线程ID不删除【即对该线程进行了偏向】
        偏向锁也可以禁用，对象锁冲突比较多的情况下，不适用偏向锁，调整VM参数即可
        当锁对象调用hashCode方法生成hashCode之后，此对象的偏向锁会被禁用【因为hashcode的记录与线程ID的记录位置冲突？】
    三锁的关系：一开始是偏向锁，当发现线程共用但共用时间不冲突时，升级为轻量级锁，当共用时间冲突时，升级为重量级锁
    批量重偏向：
        当偏向锁升级为轻量级锁或重量级锁之后，再解锁之后成为初始状态【偏向开关关闭】，即撤销偏向；
        此时JVM允许重新偏向：当撤销偏向超过20次，JVM会觉得原偏向有误，会将剩下偏向老线程的锁对象在碰到新线程使用时重新偏向到新的线程
    批量撤销：
        当撤销偏向超过40次，JVM会觉得原偏向确实错误，该类的对象不适宜偏向，因此会将该锁对象类的所有对象全部变为不可偏向的锁对象，且新new的类也不可偏向。
10. JIT即时编译器优化-锁消除
    JIT可以对非共享的锁进行锁消除